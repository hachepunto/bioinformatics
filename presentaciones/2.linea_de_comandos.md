# github.com/hachepunto/bioinformatics


# Interface de l√≠nea de comandos


La **[Interface de l√≠nea de comandos](http://en.wikipedia.org/wiki/Command-line_interface)** (CLI) es un **m√©todo para interactuar** con un programa o sistema operativo de computadora que permite al usuario dar √≥rdenes al programa **en forma de lineas de texto** sucesivas (l√≠neas de comando). 

La **CLI** es menos usada por el usuario de computadoras promedio que prefiere usar una **[Interface Gr√°fica de Usuario](http://en.wikipedia.org/wiki/Command-line_interface)** (GUI) que ofrece una est√©tica mejorada y una mayor simplificaci√≥n, a costa de un mayor consumo de recursos computacionales, y, en general, de una reducci√≥n de la funcionalidad alcanzable.

La **CLI**, sin embargo, es preferida por los usuarios avanzados de c√≥mputo dado que ofrece medios m√°s concisos y poderosos para controlar programas o sistemas operativos.

Las √≥rdenes dadas al Shell de linea de comandos com√∫nmente tiene alguna de las siguientes sintaxis:

+ *prompt comando par√°metro1 par√°metro2 par√°metro3 ... par√°metroN*
+ *prompt comando par√°metro1 | comando par√°metro2 | comando par√°metro3 ... | comando par√°metroN | > archivoSalida*

## Prompt

Caracter o caracteres que se muestran en la linea de comandos para indicar que est√° listo para recibir tus √≥rdenes.

#### UNIX/GNU/Linux
```
usuario@m√°quina:~$
```

#### Mac OS X
```
m√°quina:~ usuario$
```

#### R
```
>
```

#### Python
```
>>>
```

# Comandos b√°sicos en UNIX

Escribe uno por uno los siguientes comandos mientras explico:


***ls*** (list) es un programa para listar el contenido de la carpeta en la que estamos "parados".

Comado para ver el contenido de la carpeta donde estamos:

```
ls
```

Con estas opciones estamos cambiando el comportamiento de ls. En este caso usamos dos opciones "l" y "a". "l" cambia el formato de salida por el de "lista" y "a" indica que queremos ver todos (*all*) los archivos, tanto los visibles como los ocultos.

En los sistemas UNIX, los archivos cuyo nombre comienzan con un punto ".", son invisibles por defecto.

```
ls -la
```

***cd*** (change directory) es un programa para cambiar de directorio dentro del √°rbol de directorios del sistema.

```
cd
```

***pwd*** (print working directory) es un peque√±o programa que imprime en pantalla la ruta hacia el directorio donde estamos trabajando.

```
pwd
```

***more*** Paginador de archivos de texto plano. Este programa imprime en pantalla el contenido de archivos de texto.

```
more archivo1.txt
```

```
more archivo1.txt archivo2.txt
```



### Estructura de archivos

En los sistemas UNIX los archivos est√°n organizados por directorios. Los directorios son archivos especiales que contienen informaci√≥n que permite localizar otros archivos en los dispositivos de almacenamiento. Los directorios pueden contener a su vez otros directorios los cuales se denominan subdirectorios. A la estructura resultante de esta organizaci√≥n se le conoce como *estructura de √°rbol invertido*.

![Estructura de archivos UNIX](../imagenes/filesystem.png)

   - Directorio ra√≠z o *root* `/`: Es aquel directorio que est√° sobre todos los directorios. 

```
ls /
```
   
   - Directorio de coneccion `~`:  Es un directorio especial que representa el directorio principal del usuario (home). 

En estos comandos vamos a cambiarnos a la ra√≠z de nuestro sistema de archivos y desde ah√≠ vamos a usar `~` para "ver" que hay dentro de nuestra *home*

Not√©n que, es el *home* de nuestro usuario con el que entramos al servidor, no cualquier *home*.

```
cd /
ls
ls ~
cd ~
ls
```

   - Directorio de trabajo `.`: El punto representa el directorio en el que estamos parados

```
ls .
```

   - Directorio superior `..`: Dos puntos representa el directorio arriba del que estamos parados

```
ls ..
cd ..
ls 
```

  - Listado en formato largo con `ls -l`:

![Listado largo](../imagenes/ls_-l.png)

  - Permisos de archivos

![Permisos de archivos](../imagenes/file-permissions.jpg)  

**tree** (arbol) este programa te muestras gr√°ficamente la estructura de archivos como una serie de ramas.



```
cd
tree
```



***find*** (encontrar) Es un programa que te muestra la estructura de los elementos (archivos y carpetas) de la carpeta deseada y te permite filtrar el resultado para encontrar carpetas o archivos.

Despliega la ruta de todos los elementos a partir de donde est√©s "parado":

```
find
```

Despliega la ruta de todos los elementos dentro del folder "carpeta1":

```
find carpeta1 
```

Despliega la ruta de todos los elementos dentro del folder "carpeta2":

```
find carpeta2 
```

Despliega la ruta de todos los elementos dentro del folder "carpeta3":

```
find carpeta3 
```

En este ejemplo cambiamos los argumentos del comando *find* para que busque elementos por su nombre:

```
find carpeta1/ -name "*txt"
```

Aqu√≠ desplegamos la ruta de todos los elementos comenzando por la ra√≠z del disco:

```
find /
```

Y este es un comando s√∫per util:

  - Comando para abortar una tarea `Ctrl` + `C`


![catmatrix](../imagenes/giphy.gif)


***mkdir*** (make directory) crea carpetas.

Cambiamos a nustro home con *cd* y luego creamos la carpeta *datos.taller*:

```
cd
mkdir datos.taller
```

Nos cambiamos de lugar a *datos.taller*:

```
cd datos.taller
```

vemos el contenido de la carpeta recien creada:

```
ls
```

***wget*** (www get) Es un programa para descargar archivos de internet.

Ejecutamos el comando con una direcci√≥n URL del archivo que queremos descargar: 

```
wget "https://raw.githubusercontent.com/hachepunto/bioinformatics/master/data/breastcancer_regulon.sif"
```

Otro archivo m√°s:

```
wget -O CO2_by_year.txt "https://raw.githubusercontent.com/hachepunto/bioinformatics/master/data/data_carbondioxideyearlyemissions.txt"
```

Ahora volvemos a checar el contenido de nuestra carpeta:

```
ls
```

***cat*** (concatenate) sirve para concatenar archivos uno tras.

Imprimimos el contenido de un archivo:

```
cat breastcancer_regulon.sif
```

Ahora concatenamos los contenidos de ambos archivos:

```
cat breastcancer_regulon.sif CO2_by_year.txt
```

Nota: Los archivos no se est√°n modificando. Solo se est√° imprimiendo en pantalla. A este despliegue de su cintenido se le llama *salida standar*. 

***less*** es un paginador para ver archivos.

Vamos a visualizar uno de nuestros archivos descargados:

```
less CO2_by_year.txt
```

Dentro de `less` puedes usar flechas para recorrer el archivo que estamos visualizando. 

As√≠ mismo podemos apretar la tecla `/` para buscar el contenido del archivo. √ösalo para buscar tu pa√≠s, por ejemplo.

Para salir de `less` preciona la tecla `Q` (quit).

***man*** (manual) es un programa que muestra los manuales de los programas.

Casi todos los comando de UNIX/Linux tienen un manual que se puede desplegar usando el comando *man* y luego el nombre del comando:

```
man less
```

Las p√°ginas de manuales son documentaci√≥n acerca de los comandos y programas que tiene el sistema. Tienen una estructura constante lo que nos ayuda a ubicar la informaci√≥n que necesitamos m√°s facilmente.

Los manuales desplegados por *man* se despliegan usando *less*.

```
less -S CO2_by_year.txt
```

***cut*** Corta por columnas un archivo.

Para usar *cut* debemos indicarle qu√© columna queremos extraer del archivo usando la opci√≥n *-f*. los n√∫mero de columna se escribe como solicitamos la impresi√≥n de hojas. Ej. "1,3,5" o "1-5,7-9" o "3,2,1,10" etc.

Aqu√≠ sacamos la primera columna:

```
cut -f1 CO2_by_year.txt
```

Ejercita sacando algunas otras columnas. ¬øPuedes sacar la columna 2 del archivo "breastcancer_regulon.sif"? ¬øy la 4?


### Salida estandar

La salida estandar (_Standar output_ o _stdout_) se refiere al _flujo estandarizado_ de datos que produce un programa de linea de comandos. Este flujo de datos, el cual es texto plano, facilita la exportaci√≥n a diferentes dispositivos como impresoras, monitores o bien otros programas. 

Para redirigir la salida de un programa se usa **|**  ( **pipe** o tuber√≠a ). Este es un m√©todo para encadenar programas de tal modo que la salida de uno es la entrada del que sigue. Se usa una barra vertical para separar los programas a usar.

Ejemplo sencillo:

```
cut -f2 breastcancer_regulon.sif | less
```

Aqu√≠ usamos *cut* para extraer la columna 2 del archivo "breastcancer_regulon.sif" y se lo pasa a paginador less. 

Las pipes (o tuber√≠as) son una de las herramientas m√°s poderosas de la interface de linea de comandos. Nos permite operar con diferentes herramientas sobre un mismo conjunto de informaci√≥n sin modificar el archivo que contiene nuestros datos.


***sort*** ordena listas.

Con este comando usamos *sort* para ordenar alfabeticamente **los renglones** del archivo "breastcancer_regulon.sif" y vemos el resultado usando *less*.

```
sort breastcancer_regulon.sif | less
```

¬øQu√© est√° haciendo el siguiente comando?

``` 
cut -f2 breastcancer_regulon.sif | sort | less
```

¬øY este otro?

``` 
cut -f2 breastcancer_regulon.sif | sort -u | less
```

Usando *man* descubre qu√© hace la opci√≥n "-u" del comando *sort*.


***tail*** (final) muestra el final de un archivo.

Este comando muestras los 10 √∫ltimos renglones del archivo "breastcancer_regulon.sif"

```
tail breastcancer_regulon.sif
```

¬øPara qu√© crees que sirve la opcion "-n" en este caso?

```
tail -n 50 breastcancer_regulon.sif
```

Usa `man tail` para descubrir para qu√© sirve el signo de "+" en el sigueinte comando:

```
tail  -n +2 breastcancer_regulon.sif | less
```

Aqu√≠ se utilizan tres comandos consecutivos, *cut*, *tail* y *less*. ¬øQu√© sucede en cada paso? ¬øQu√© pasa si quitamos pasos?

```
cut -f1 breastcancer_regulon.sif | tail  -n +2 | less
```

Aqu√≠ a√±adimos el comando *sort* ¬øQu√© cosas est√° haciendo?

```
cut -f1 breastcancer_regulon.sif | tail  -n +2 | sort -u | less
```

***sed*** (stream editor) sed es un poderoso programa que sustituye caracteres en archivos de texto.

El comando *sed* utiliza lo que se llama **expresiones de sustituci√≥n** o **comandos de sustituci√≥n** para especificar que parte de un texto se tiene que sustituir.

Observa a ver el archivo "CO2_by_year.txt" sin cambios:

```
less -S CO2_by_year.txt
```

Mira el siguiente comando y estudia su resultado en la terminal:

```
sed -e 's/NA/0/g' CO2_by_year.txt | less -S
```

La expresi√≥n de sustituci√≥n es el que est√° despu√©s de la opci√≥n "-e" (_expression_) y puede haber tantas como se requiera. f√≠jate que est√° limitada por unas comillas sencillas y est√° constituida por cuatro regiones. Algo as√≠ como '1/2/3/4'. En el espacio 1 se especifica qu√© tipo de comando se va a usar. El m√°s usado es la sustituci√≥n (_s_) pero no es el √∫nico en sed, hay muchos otros como borrar (_d_), imprimir (_p_), insertar (_i_) y muchos m√°s. (Adivina donde encuentras todos...)

Ahora vamos a desglosar que es lo que hace el siguiente comando.

``` 
cut -f1 breastcancer_regulon.sif | tail  -n +2 | sort -u | sed -e 's/AFF4/AF5Q31/' -e 's/APBB2/FE65L1/' | less
```

üß¨ ¬øMe pueden decir la interpretaci√≥n biol√≥gica de lo que est√° haciendo este comando? 

*Recuerda, a√∫n no hemos modificado o creado ning√∫n archivo.*


***>*** salva a archivo la salida est√°ndar.

El s√≠mbolo *>* sirve para indicarle a la terminal que redirija la salida estandar (salida de texto plano) a un nuevo archivo en nuestro disco.

En este comando, en lugar de redirigir al comando *less* al final del comando, usamos *>* para que se escriba un nuevo archivo que estamos nombrando en este caso "TFs.txt".

``` 
cut -f1,4 breastcancer_regulon.sif | tail  -n +2 | sort -u | sed -e 's/AFF4/AF5Q31/' -e 's/APBB2/FE65L1/' > TFs.txt
```

Nos sersioramos que hay un nuevo archivo llamado "TFs.txt" en nuestro directorio de trabajo:

```
ls
```

Nota que como no le dimos una ruta distinta al comando, el nuevo archivo se guard√≥ directamente en el directorio de trabajo.

Podemos ver su contenido:

```
less TFs.txt
```

Si necesitaras que el nuevo archivo se guardara en "carpeta4" ¬øqu√© har√≠as? 

***wc*** (word count) cuenta el n√∫mero de palabras y de renglones.

El comando *wc* devuelve tres cuentas: n√∫mero de renglones, n√∫mero de palabras y n√∫mero de caracteres.

```
wc TFs.txt breastcancer_regulon.sif
```

La opci√≥n "-l" hace que *wc* solo devuelva en n√∫mero de renglones (_lines_).

```
wc -l TFs.txt breastcancer_regulon.sif
```

En este comando estamos cortando la segunda columna de la red (blancos) y estamos contando cuantos renglones quedan.

```
cut -f2 breastcancer_regulon.sif | wc -l
```

En este rengl√≥n, antes de contar los renglones con *wc* est√°mos sacando los valores √∫nicos con *sorte -u*:

```
cut -f2 breastcancer_regulon.sif | sort -u | wc -l
```


üß¨ ¬øEs el mismo valor? ¬øQu√© significar√≠a esto biol√≥gicamente hablando?

***uniq*** busca repetidos en una lista ordenada.

¬øCual es el resultado de la cuenta en estos dos comandos?

```
cut -f2 breastcancer_regulon.sif | wc -l
cut -f2 breastcancer_regulon.sif | uniq | wc -l
```

Resulta que uniq requiere que los renglones est√©n ya ordenados ya que detecta renglones contiguos iguales.

```
cut -f2 breastcancer_regulon.sif | wc -l
cut -f2 breastcancer_regulon.sif | sort | uniq | wc -l
```

El comando *uniq* tiene una opci√≥n interesate. Busca la opci√≥n "-c" de *uniq* en su manual. Luego observa el siguiente comando y expl√≠came que hace.

```
cut -f1 breastcancer_regulon.sif | sort | uniq -c | less
```

Ahora busca en el manual de *sort* que son las opciones "n" y "r".

```
cut -f1 breastcancer_regulon.sif | sort | uniq -c | sort -nr | less
```

üß¨ ¬øQu√© significar√≠a esto biol√≥gicamente hablando?


***grep*** (get all lines matching the regular expression and print (g/re/p)) es una herramienta muy poderosa para buscar cadenas de texto dentro de un archivo. Est√° pensado para trabajar con expresiones regulares (que no trataremos en este curso).

Busquemos con grep un gen popular como TP53.

```
grep "TP53" breastcancer_regulon.sif
```

Este comando busc√≥ cualquier coincidencia con el texto "TP53". Pero digamos que nosotros estamos interesados en explorar el papel de TP53 como Factor de transcripci√≥n (columna 1), no como blanco (columna 2).

Para ello usamos una expresi√≥n regular "^" que significa "principio del rengl√≥n".

```
grep "^TP53" breastcancer_regulon.sif
```

Ahora solo salen los renglones que dicen "TP53" pero hay otras coincidencias que no nos ayudan a explorar al gen "TP53". ¬øCuales son? 

Vamos a usar la opci√≥n "-w" de grep que significa "encuentra palabras":

```
grep -w "^TP53" breastcancer_regulon.sif
```

üß¨ Observa los dos siguientes comandos y dime cual es su significado biol√≥gico.

```
grep -w "^TP53" breastcancer_regulon.sif | wc -l
grep -w "^TP53" breastcancer_regulon.sif | cut -f2 | sort -u | wc -l
```

Vamos a guardar este resultado:

```
grep -w "^TP53" breastcancer_regulon.sif | cut -f2 | sort -u > TP53_regulon.txt
```

Podemos imprimirlo:

```
cat TP53_regulon.txt
```

Describe qu√© est√° haciendo este comando:

```
cat TP53_regulon.txt TFs.txt
```

***paste*** (pegar) pega columnas una contigua a la otra

Solo para ver como trabaja, unamos estas dos listas en una sola salida:

```
paste TFs.txt TP53_regulon.txt | less
```

***mv*** (move) comando que sirve para mover o renombrar y archivo o carpeta.

Veamos que tenemos en nuestra carpeta de trabajo:

```
ls -l
```

*Renombrar*

Para renombrar tenemos que darle a *mv* de argumento, primero el archivo tal cual est√° seguido de como queremos que se llame: 

```
mv TFs.txt transcriptionFactors.txt
```

```
ls -l
```

*Mover*

Vamos a hacer una carpeta nueva para probar mover archivos con el comando *mv*:

```
mkdir factores_de_transcripcion
```

Ahora lo que tenemos que hacer es darle de argumento a *mv*, primero la ruta al archivo que queremos mover, y luego una ruta a una **carpeta** (no a un archivo) a donde queramos moverlo. 

```
mv transcriptionFactors.txt factores_de_transcripcion/
```

Veamos nuestro resultado:

```
ls 
ls factores_de_transcripcion/
```

***cp*** (copiar) Comando que sirve para copiar archivos o carpetas

Si queremos generar una copia id√©ntica de un archivo usamos este comando de forma muy similar a como movemos archivos con *mv*. Le damos como argumento a *cp* primero el archivo que queremos copiar y luego la ruta a donde queremos que est√© la copia nueva: 

```
cp TP53_regulon.txt factores_de_transcripcion/
```

Veamos nuestro resultado:

```
ls 
ls factores_de_transcripcion/
```



***rm*** (remove) Es el comando que sirve para eliminar archivos o carpetas. No pregunta si s√≠ deseas borrar, hace lo que le indicas.

*Borrar archivos*

Le damos la ruta al o los archivos que queremos borrar:

```
rm TP53_regulon.txt factores_de_transcripcion/TP53_regulon.txt
```

*Borrar carpetas*

¬øQu√© pasa si intentamos esto?

```
rm factores_de_transcripcion/
```

rm: factores_de_transcripcion/: is a directory

Resulta que, por seguridad. rm no puede borrar carpetas sin que se lo especifiques. Esto se hace usando la opci√≥n "-r" (recursivamente) con la cual hay m√°s seguridad que est√°s ejecutando el comando con tu deseo expl√≠cito.

```
rm -r factores_de_transcripcion/
```

## rsync

[rsync](https://rsync.samba.org/) es una utilidad para la transferencia y sincronizaci√≥n eficiente  de archivos a travez de sistemas de c√≥mputo. rsync se usa t√≠picamente para sincronizar archivos y directorios entre dos sistemas distintos.

Sintaxis general:

```
rsync [OPTION] ‚Ä¶ SRC ‚Ä¶ [USER@]HOST:DEST
rsync [OPTION] ‚Ä¶ [USER@]HOST:SRC [DEST]
```

Por ejemplo


```
cd
rsync -avz alumnoX@drona.inmegen.gob.mx:datos.taller/C02* .
```
M√°s info:
[Lista de comandos de UNIX en la Wikipedia](http://en.wikipedia.org/wiki/List_of_Unix_commands)


# Varaibles de entorno

Cada vez que se genera una sesi√≥n de shell, se lleva a cabo un proceso para recopilar y compilar informaci√≥n que deber√≠a estar disponible para el proceso de shell y sus procesos secundarios. Los datos para estas configuraciones se obtienen de diversos archivos y configuraciones en el sistema. Mucha de esta configuraci√≥n del sistema se guarda en las llamas *Varabiles de entorno*. Estas son listas de t√©rminos que guardan informaci√≥n. Por convenci√≥n se usan pal√°bras en may√∫sculas para distinguirlas.

```
printenv
```

Algunas variables de entorno y de shell son muy √∫tiles y se utilizan con bastante frecuencia. Aqu√≠ hay algunas variables frecuentes de entorno con las que se encontrar√°:

* **SHELL**: Describe el shell que interpretar√° cualquier comando que ingrese. En la mayor√≠a de los casos, ser√° bash de forma predeterminada, pero se pueden establecer otros valores si prefiere otras opciones.

* **TERM**: Especifica el tipo de terminal a emular cuando se ejecuta el shell. Se pueden emular diferentes terminales de hardware para diferentes requisitos de funcionamiento. Sin embargo, generalmente no tendr√° que preocuparse por esto.
* **USER**: El usuario que inici√≥ sesi√≥n actualmente.
* **PWD**: El directorio actual de trabajo.
* **OLDPWD**: El directorio anterior de trabajo. Esto se mantiene en el shell para volver a su directorio anterior ejecutando cd -.
* **LS_COLORS**: Define los c√≥digos de color que se utilizan para a√±adir de forma opcional un resultado de color al comando ls. Esto se utiliza para distinguir diferentes tipos de archivos y proporcionar m√°s informaci√≥n al usuario de forma r√°pida.
* **MAIL**: La ruta al buz√≥n del usuario actual.
* **PATH**: Una lista de directorios que el sistema comprobar√° cuando busque comandos. Cuando un usuario escriba un comando, el sistema comprobar√° los directorios en este orden para el ejecutable.
* **LANG**: Las configuraciones actuales de idioma y localizaci√≥n, incluida la codificaci√≥n de caracteres.
* **HOME**: El directorio principal del usuario actual.
* **_**: El comando m√°s reciente ejecutado anteriormente.

## PATH

Esta es una variable con la que se topar√°n m√°s de una vez. Para consultarla podemos usar el comando ***echo***

***echo*** Despliega una linea de texto.

```
echo "Hola shell"
```

Para desplegar el valor de una variable es necesario a√±adile el sigono de pesos "\$"

```
echo $PATH
```

Con ***echo*** podemos generar o modificar archivos.


```
echo "Hola shell" > hola.txt
```

Se usan dos ">" para a√±adir texto a un archivo. 

```
echo "¬øQu√© hay de nuevo?" >> hola.txt
```

Vamos a cambiar la variable **PATH** para a√±adir un programa. Cuando estamos tecleando muy r√°pido, com√∫nmente nos equivocamos al escribir. Unos de los comandos que m√°s usamos tambi√©n es uno en el que m√°s nos equivocamos.

```
sl
```
¬øQu√© error devuelve?

Para usar un programa que nosotros tenemos en alg√∫n lugar de nuestra maquina podemos llamarlo con la ruta (path) absoluta:

```
/home/instalaciones/sl-5.02/sl
```

Pero podemos configurar nuestra variable de entorno *PATH* para que siembre busque commandos en alguna carpeta espec√≠fica. En este ejemplo vamos a pedirle que busque en la carpeta "/home/instalaciones/sl-5.02/"

```
echo "export PATH='/home/instalaciones/sl-5.02/:$PATH'" >> ~/.bashrc
source ~/.bashrc
```

Ahora intentemos otra vez:

```
sl
```

## Tarea

Saber usar estas herramientas, como en cualquier otro trabajo, requiere pr√°ctica para mejorar nuestro desempe√±o. Por favor, de tarea, ve [este video](https://www.youtube.com/watch?v=e9NjhfsdEGA) de Youtube y lee y haz los ejercicios de [esta p√°gina](https://www.educatica.es/sistemas-operativos/principios-basicos/sistemas-de-ficheros/rutas-de-ficheros-y-directorios/) en internet.  

